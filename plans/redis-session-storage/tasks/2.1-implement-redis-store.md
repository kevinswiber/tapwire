# Task 2.1: Implement RedisStore

## Objective
Implement the `SessionStore` trait for Redis, providing a fully functional Redis-backed storage implementation for SessionManager.

## Prerequisites
- Task 1.1 completed (SessionStore trait defined)
- Task 1.2 completed (Redis data model designed)
- Redis client library selected (redis-rs)

## Deliverables

### 1. Add Redis Dependencies
Update `shadowcat/Cargo.toml`:
```toml
[dependencies]
redis = { version = "0.27", features = ["tokio-comp", "connection-manager"] }
bb8 = "0.8"
bb8-redis = "0.16"
serde_json = "1.0"
bincode = "1.3"  # Or messagepack
```

### 2. Implement RedisStore
Location: `shadowcat/src/session/storage/redis.rs`

```rust
use super::{SessionStore, Session, SessionResult, SessionError};
use redis::{aio::ConnectionManager, AsyncCommands, pipe};
use std::sync::Arc;

pub struct RedisStore {
    client: redis::Client,
    manager: ConnectionManager,
    config: RedisConfig,
    key_prefix: String,
}

pub struct RedisConfig {
    pub url: String,
    pub key_prefix: String,
    pub ttl: Duration,
    pub operation_timeout: Duration,
}

impl RedisStore {
    pub async fn new(config: RedisConfig) -> SessionResult<Self> {
        let client = redis::Client::open(config.url.clone())
            .map_err(|e| SessionError::Storage(format!("Redis connection failed: {e}")))?;
        
        let manager = ConnectionManager::new(client.clone()).await
            .map_err(|e| SessionError::Storage(format!("Redis manager failed: {e}")))?;
        
        Ok(Self {
            client,
            manager,
            config,
            key_prefix: config.key_prefix,
        })
    }
    
    fn session_key(&self, id: &SessionId) -> String {
        format!("{}:session:{}", self.key_prefix, id)
    }
    
    fn frames_key(&self, id: &SessionId) -> String {
        format!("{}:frames:{}", self.key_prefix, id)
    }
    
    fn active_set_key(&self) -> String {
        format!("{}:sessions:active", self.key_prefix)
    }
}
```

### 3. Implement Core Methods

#### Session Operations
```rust
#[async_trait]
impl SessionStore for RedisStore {
    async fn create_session(&self, session: Session) -> SessionResult<()> {
        let session_key = self.session_key(&session.id);
        let active_set = self.active_set_key();
        
        // Serialize session fields
        let mut pipe = pipe();
        pipe.atomic();
        
        // Set session hash fields
        pipe.hset(&session_key, "id", session.id.to_string());
        pipe.hset(&session_key, "transport_type", format!("{:?}", session.transport_type));
        pipe.hset(&session_key, "status", format!("{:?}", session.status));
        pipe.hset(&session_key, "state", serde_json::to_string(&session.state)?);
        pipe.hset(&session_key, "created_at", session.created_at);
        pipe.hset(&session_key, "last_activity", session.last_activity);
        pipe.hset(&session_key, "frame_count", session.frame_count);
        
        if let Some(ref info) = session.client_info {
            pipe.hset(&session_key, "client_info", info);
        }
        
        // Add to active set
        pipe.sadd(&active_set, session.id.to_string());
        
        // Set TTL
        pipe.expire(&session_key, self.config.ttl.as_secs() as i64);
        
        // Execute pipeline
        pipe.query_async(&mut self.manager.clone()).await
            .map_err(|e| SessionError::Storage(format!("Failed to create session: {e}")))?;
        
        Ok(())
    }
    
    async fn get_session(&self, id: &SessionId) -> SessionResult<Session> {
        let session_key = self.session_key(id);
        
        // Get all hash fields
        let data: HashMap<String, String> = self.manager.clone()
            .hgetall(&session_key).await
            .map_err(|e| SessionError::Storage(format!("Failed to get session: {e}")))?;
        
        if data.is_empty() {
            return Err(SessionError::NotFound(format!("Session {} not found", id)));
        }
        
        // Deserialize session
        let session = Session {
            id: SessionId::from_str(&data["id"])?,
            transport_type: parse_transport_type(&data["transport_type"])?,
            status: parse_status(&data["status"])?,
            state: serde_json::from_str(&data["state"])?,
            created_at: data["created_at"].parse()?,
            last_activity: data["last_activity"].parse()?,
            frame_count: data["frame_count"].parse()?,
            client_info: data.get("client_info").cloned(),
            server_info: data.get("server_info").cloned(),
            version_state: data.get("version_state")
                .map(|s| serde_json::from_str(s))
                .transpose()?,
            tags: data.get("tags")
                .map(|s| serde_json::from_str(s))
                .transpose()?
                .unwrap_or_default(),
        };
        
        Ok(session)
    }
    
    async fn update_session(&self, session: Session) -> SessionResult<()> {
        // Similar to create_session but without adding to active set
        // Use HSET to update existing fields
    }
    
    async fn delete_session(&self, id: &SessionId) -> SessionResult<()> {
        let session_key = self.session_key(id);
        let frames_key = self.frames_key(id);
        let active_set = self.active_set_key();
        
        let mut pipe = pipe();
        pipe.atomic();
        pipe.del(&session_key);
        pipe.del(&frames_key);
        pipe.srem(&active_set, id.to_string());
        
        pipe.query_async(&mut self.manager.clone()).await
            .map_err(|e| SessionError::Storage(format!("Failed to delete session: {e}")))?;
        
        Ok(())
    }
    
    async fn list_sessions(&self) -> SessionResult<Vec<Session>> {
        let active_set = self.active_set_key();
        
        // Get all active session IDs
        let ids: Vec<String> = self.manager.clone()
            .smembers(&active_set).await
            .map_err(|e| SessionError::Storage(format!("Failed to list sessions: {e}")))?;
        
        // Fetch sessions in parallel
        let mut sessions = Vec::new();
        for id_str in ids {
            if let Ok(id) = SessionId::from_str(&id_str) {
                if let Ok(session) = self.get_session(&id).await {
                    sessions.push(session);
                }
            }
        }
        
        Ok(sessions)
    }
    
    async fn count_sessions(&self) -> SessionResult<usize> {
        let active_set = self.active_set_key();
        
        let count: usize = self.manager.clone()
            .scard(&active_set).await
            .map_err(|e| SessionError::Storage(format!("Failed to count sessions: {e}")))?;
        
        Ok(count)
    }
}
```

#### Frame Operations
```rust
impl RedisStore {
    async fn add_frame(&self, envelope: MessageEnvelope) -> SessionResult<()> {
        let frames_key = self.frames_key(envelope.session_id());
        
        // Serialize frame
        let frame_data = bincode::serialize(&envelope)
            .map_err(|e| SessionError::Storage(format!("Failed to serialize frame: {e}")))?;
        
        // Add to list and update session
        let mut pipe = pipe();
        pipe.atomic();
        pipe.rpush(&frames_key, frame_data);
        pipe.hincrby(self.session_key(envelope.session_id()), "frame_count", 1);
        pipe.hset(self.session_key(envelope.session_id()), "last_activity", 
                  SystemTime::now().duration_since(UNIX_EPOCH)?.as_millis() as u64);
        
        pipe.query_async(&mut self.manager.clone()).await
            .map_err(|e| SessionError::Storage(format!("Failed to add frame: {e}")))?;
        
        Ok(())
    }
    
    async fn get_frames(&self, session_id: &SessionId) -> SessionResult<Vec<MessageEnvelope>> {
        let frames_key = self.frames_key(session_id);
        
        // Get all frames
        let frame_data: Vec<Vec<u8>> = self.manager.clone()
            .lrange(&frames_key, 0, -1).await
            .map_err(|e| SessionError::Storage(format!("Failed to get frames: {e}")))?;
        
        // Deserialize frames
        let frames = frame_data.into_iter()
            .map(|data| bincode::deserialize(&data))
            .collect::<Result<Vec<_>, _>>()
            .map_err(|e| SessionError::Storage(format!("Failed to deserialize frames: {e}")))?;
        
        Ok(frames)
    }
}
```

### 4. Add Connection Pool Support
```rust
use bb8::{Pool, PooledConnection};
use bb8_redis::RedisConnectionManager;

pub struct PooledRedisStore {
    pool: Pool<RedisConnectionManager>,
    config: RedisConfig,
}

impl PooledRedisStore {
    pub async fn new(config: RedisConfig) -> SessionResult<Self> {
        let manager = RedisConnectionManager::new(config.url.clone())
            .map_err(|e| SessionError::Storage(format!("Redis pool failed: {e}")))?;
        
        let pool = Pool::builder()
            .max_size(20)
            .min_idle(Some(5))
            .connection_timeout(Duration::from_secs(5))
            .build(manager).await
            .map_err(|e| SessionError::Storage(format!("Pool creation failed: {e}")))?;
        
        Ok(Self { pool, config })
    }
    
    async fn get_conn(&self) -> SessionResult<PooledConnection<'_, RedisConnectionManager>> {
        self.pool.get().await
            .map_err(|e| SessionError::Storage(format!("Failed to get connection: {e}")))
    }
}
```

## Testing Implementation

### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_redis_store_lifecycle() {
        // Use testcontainers or mock
        let config = RedisConfig {
            url: "redis://localhost:6379".to_string(),
            key_prefix: "test".to_string(),
            ttl: Duration::from_secs(60),
            operation_timeout: Duration::from_secs(1),
        };
        
        let store = RedisStore::new(config).await.unwrap();
        
        // Test create
        let session = Session::new(SessionId::new(), TransportType::Stdio);
        store.create_session(session.clone()).await.unwrap();
        
        // Test get
        let retrieved = store.get_session(&session.id).await.unwrap();
        assert_eq!(retrieved.id, session.id);
        
        // Test update
        let mut updated = retrieved.clone();
        updated.frame_count = 10;
        store.update_session(updated).await.unwrap();
        
        // Test delete
        store.delete_session(&session.id).await.unwrap();
        assert!(store.get_session(&session.id).await.is_err());
    }
}
```

### Integration Tests
Location: `tests/redis_integration.rs`
```rust
use testcontainers::{clients, images::redis::Redis};

#[tokio::test]
async fn test_redis_store_with_real_redis() {
    let docker = clients::Cli::default();
    let redis_container = docker.run(Redis::default());
    let port = redis_container.get_host_port_ipv4(6379);
    
    let config = RedisConfig {
        url: format!("redis://127.0.0.1:{}", port),
        // ... rest of config
    };
    
    // Run comprehensive tests
}
```

## Error Handling

### Connection Errors
- Implement retry with exponential backoff
- Log connection failures
- Return appropriate SessionError variants

### Serialization Errors
- Handle incompatible data gracefully
- Log serialization failures
- Consider version migration

### Timeout Handling
- Use tokio::time::timeout for operations
- Configure per-operation timeouts
- Return timeout errors clearly

## Performance Optimization

### 1. Use Pipelining
```rust
// Instead of multiple round trips
let mut pipe = pipe();
pipe.hset(...);
pipe.sadd(...);
pipe.expire(...);
pipe.query_async(&mut conn).await?;
```

### 2. Implement Caching Layer
```rust
struct CachedRedisStore {
    redis: RedisStore,
    cache: Arc<RwLock<LruCache<SessionId, Session>>>,
}
```

### 3. Batch Operations
```rust
async fn get_sessions_batch(&self, ids: &[SessionId]) -> SessionResult<Vec<Session>> {
    // Use pipeline to fetch multiple sessions
}
```

## Success Criteria

- ✅ All SessionStore trait methods implemented
- ✅ Connection pooling configured
- ✅ Error handling comprehensive
- ✅ Unit tests passing
- ✅ Integration tests with real Redis
- ✅ Performance meets targets (< 5ms p95)

## Notes

- Start with basic implementation, optimize later
- Consider using redis::aio::MultiplexedConnection for better performance
- Plan for Redis Cluster support in future
- Document Redis version requirements (>= 6.0)
- Consider implementing health checks

## Estimated Duration
4 hours

## Dependencies
- Task 1.1 (SessionStore trait)
- Task 1.2 (Redis data model)