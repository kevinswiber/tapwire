# Task 2.5.2: EventStore Refactor

## Objective
Refactor EventStore trait and implementations to support stream-specific event storage and retrieval using composite keys (session_id, stream_id).

## Dependencies
- Task 2.5.1 (Stream Manager Implementation) must be complete

## Implementation Steps

### Step 1: Update EventStore Trait
- [ ] Add `stream_id` parameter to all methods
- [ ] Add stream-specific cleanup method
- [ ] Update documentation
- [ ] Consider backwards compatibility

### Step 2: Update StoredEvent Structure
- [ ] Add `stream_id` field
- [ ] Update constructors
- [ ] Maintain serialization compatibility

### Step 3: Refactor InMemoryEventStore
- [ ] Change from `HashMap<SessionId, VecDeque<Event>>` to nested structure
- [ ] Use composite key: `HashMap<SessionId, HashMap<StreamId, VecDeque<Event>>>`
- [ ] Update all method implementations
- [ ] Maintain max events per stream limit

### Step 4: Update PersistenceWorker Integration
- [ ] Update PersistenceRequest enum variants
- [ ] Add stream_id to UpdateLastEventId
- [ ] Add stream_id to StoreEvent
- [ ] Update cleanup logic for streams

### Step 5: Migration Support
- [ ] Add migration helper for existing stores
- [ ] Provide default stream ID for non-SSE transports
- [ ] Document migration path

## Updated Interface

```rust
#[async_trait]
pub trait EventStore: Send + Sync {
    /// Store an event for a specific stream within a session
    async fn store_event(
        &self, 
        session_id: &str, 
        stream_id: &str,
        event_id: String, 
        data: Value
    );
    
    /// Get events after a specific event ID for the SAME stream
    async fn get_events_after(
        &self, 
        session_id: &str,
        stream_id: &str,
        after_event_id: &str
    ) -> Vec<StoredEvent>;
    
    /// Get all events for a specific stream
    async fn get_stream_events(
        &self,
        session_id: &str,
        stream_id: &str
    ) -> Vec<StoredEvent>;
    
    /// Clear all streams for a session
    async fn clear_session(&self, session_id: &str);
    
    /// Clear a specific stream
    async fn clear_stream(&self, session_id: &str, stream_id: &str);
    
    /// Get stream count for a session
    async fn stream_count(&self, session_id: &str) -> usize;
}
```

## Data Structure Changes

```rust
pub struct InMemoryEventStore {
    /// Nested structure: Session -> Stream -> Events
    sessions: Arc<RwLock<HashMap<String, HashMap<String, VecDeque<StoredEvent>>>>>,
    /// Maximum events to keep per stream
    max_events_per_stream: usize,
}

pub struct StoredEvent {
    pub id: String,
    pub stream_id: String,  // NEW
    pub data: Value,
    pub timestamp: u64,
}
```

## Testing Requirements
- [ ] Test stream isolation (events don't leak between streams)
- [ ] Test stream-specific retrieval
- [ ] Test nested cleanup
- [ ] Test max events per stream
- [ ] Test concurrent access to different streams

## Migration Considerations
- Existing event stores will need migration
- Consider providing compatibility layer
- Default stream ID for stdio transport?

## Success Criteria
- [ ] Events are properly isolated by stream
- [ ] Stream-specific replay works correctly
- [ ] Cleanup removes stream data properly
- [ ] All existing tests updated and passing
- [ ] New stream-specific tests pass

## Duration
4 hours

## Files to Modify
- `crates/mcp/src/events/store.rs` - Main refactor
- `crates/mcp/src/session/persistence_worker.rs` - Update integration
- `crates/mcp/src/transport/http/streaming/event_tracker.rs` - Update usage
- All test files using EventStore